interface ChangeAnalysis {
  type: string;
  scope?: string;
  description: string;
  files: Array<{
    path: string;
    status: 'added' | 'modified' | 'deleted' | 'renamed';
    additions: number;
    deletions: number;
  }>;
  commits: Array<{
    hash: string;
    message: string;
    author: string;
    date: string;
  }>;
  stats: {
    additions: number;
    deletions: number;
    filesChanged: number;
  };
}

export async function generatePRDescription(changes: ChangeAnalysis): Promise<string> {
  const {
    type,
    scope,
    description,
    files,
    commits,
    stats,
  } = changes;

  // Group files by their status
  const filesByStatus = files.reduce((acc, file) => {
    const { status } = file;
    if (!acc[status]) acc[status] = [];
    acc[status].push(file);
    return acc;
  }, {} as Record<string, typeof files>);

  // Generate description sections
  const sections = [
    generateSummarySection(type, scope, description),
    generateChangesSection(filesByStatus),
    generateCommitsSection(commits),
    generateStatsSection(stats),
    generateFooterSection(),
  ];

  return sections.join('\n\n');
}

function generateSummarySection(type: string, scope: string | undefined, description: string): string {
  const typeEmoji = getTypeEmoji(type);
  const scopeText = scope ? ` (${scope})` : '';
  
  return `## Summary\n${typeEmoji} ${type}${scopeText}: ${description}`;
}

function generateChangesSection(filesByStatus: Record<string, Array<any>>): string {
  const sections = [];
  sections.push('## Changes');

  if (filesByStatus.added?.length) {
    sections.push('### âœ¨ Added Files');
    sections.push(filesByStatus.added.map(f => `- \`${f.path}\``).join('\n'));
  }

  if (filesByStatus.modified?.length) {
    sections.push('### ğŸ”„ Modified Files');
    sections.push(filesByStatus.modified.map(f => `- \`${f.path}\``).join('\n'));
  }

  if (filesByStatus.deleted?.length) {
    sections.push('### ğŸ—‘ï¸ Deleted Files');
    sections.push(filesByStatus.deleted.map(f => `- \`${f.path}\``).join('\n'));
  }

  if (filesByStatus.renamed?.length) {
    sections.push('### ğŸ“ Renamed Files');
    sections.push(filesByStatus.renamed.map(f => `- \`${f.path}\``).join('\n'));
  }

  return sections.join('\n\n');
}

function generateCommitsSection(commits: ChangeAnalysis['commits']): string {
  if (commits.length === 0) return '';

  const commitList = commits
    .map(commit => {
      const shortHash = commit.hash.slice(0, 7);
      return `- ${commit.message} (${shortHash})`;
    })
    .join('\n');

  return `## Commits\n\n${commitList}`;
}

function generateStatsSection(stats: ChangeAnalysis['stats']): string {
  return `## Statistics
- ğŸ“Š Files changed: ${stats.filesChanged}
- âœ… Additions: ${stats.additions}
- âŒ Deletions: ${stats.deletions}`;
}

function generateFooterSection(): string {
  return `---
> Generated by [Automate PR](https://github.com/your-org/automate-pr)
> 
> ğŸ“ Please review the changes carefully before merging.
> âš ï¸ Make sure all tests pass and code quality standards are met.`;
}

function getTypeEmoji(type: string): string {
  const emojiMap: Record<string, string> = {
    feat: 'âœ¨',
    fix: 'ğŸ›',
    docs: 'ğŸ“š',
    style: 'ğŸ’…',
    refactor: 'â™»ï¸',
    perf: 'âš¡ï¸',
    test: 'ğŸ§ª',
    build: 'ğŸ› ï¸',
    ci: 'âš™ï¸',
    chore: 'ğŸ§¹',
    revert: 'âª',
  };

  return emojiMap[type] || 'ğŸ”„';
} 